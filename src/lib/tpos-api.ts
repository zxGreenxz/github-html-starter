import { TPOS_CONFIG, getTPOSHeaders, getActiveTPOSToken, cleanBase64, randomDelay } from "./tpos-config";

// =====================================================
// TPOS PRODUCT SEARCH
// =====================================================

/**
 * T√¨m ki·∫øm s·∫£n ph·∫©m t·ª´ TPOS theo m√£ s·∫£n ph·∫©m
 */
export async function searchTPOSProduct(productCode: string): Promise<TPOSProductSearchResult | null> {
  const { queryWithAutoRefresh } = await import('./query-with-auto-refresh');
  
  return queryWithAutoRefresh(async () => {
    const token = await getActiveTPOSToken();
    if (!token) {
      throw new Error("TPOS Bearer Token not found. Please configure in Settings.");
    }

    const url = `https://tomato.tpos.vn/odata/Product/OdataService.GetViewV2?Active=true&DefaultCode=${encodeURIComponent(productCode)}&$top=50&$orderby=DateCreated desc&$count=true`;
    
    console.log(`üîç Searching TPOS for product: ${productCode}`);
    
    const response = await fetch(url, {
      method: 'GET',
      headers: await getTPOSHeaders(token),
    });

    if (!response.ok) {
      throw new Error(`TPOS API error: ${response.status}`);
    }

    const data = await response.json();
    
    if (data.value && data.value.length > 0) {
      console.log(`‚úÖ Found product in TPOS:`, data.value[0]);
      return data.value[0] as TPOSProductSearchResult;
    }

    console.log(`‚ùå Product not found in TPOS: ${productCode}`);
    return null;
  }, 'tpos');
}

// =====================================================
// TYPE DEFINITIONS
// =====================================================

export interface TPOSProductSearchResult {
  Id: number;
  Name: string;
  NameGet: string;
  DefaultCode: string;
  Barcode: string;
  StandardPrice: number;
  ListPrice: number;
  ImageUrl: string;
  UOMName: string;
  QtyAvailable: number;
  Active: boolean;
}

// ===== FETCH & EDIT TPOS PRODUCT INTERFACES =====

/**
 * Full product details t·ª´ ProductTemplate({Id})
 */
export interface TPOSProductFullDetails {
  // === BASIC INFO ===
  Id: number;
  Name: string;
  NameGet?: string;
  DefaultCode: string;
  Barcode: string | null;
  Type: string;
  NameNoSign?: string | null;
  
  // === PRICES ===
  ListPrice: number;
  PurchasePrice: number;
  StandardPrice: number;
  LstPrice?: number;
  DiscountSale?: number | null;
  DiscountPurchase?: number | null;
  OldPrice?: number | null;
  
  // === QUANTITIES ===
  QtyAvailable: number;
  QtyForecast: number;
  VirtualAvailable?: number;
  OutgoingQty?: number | null;
  IncomingQty?: number | null;
  InitInventory?: number;
  
  // === IMAGE ===
  Image?: string | null;
  ImageUrl: string | null;
  Thumbnails?: any[];
  
  // === FLAGS ===
  Active: boolean;
  SaleOK: boolean;
  PurchaseOK: boolean;
  AvailableInPOS: boolean;
  IsDiscount?: boolean;
  IsCombo?: boolean | null;
  
  // === RELATIONS ===
  UOM: { Id: number; Name: string } | null;
  UOMPO: { Id: number; Name: string } | null;
  Categ: { Id: number; Name: string; CompleteName: string } | null;
  POSCateg: { Id: number; Name: string } | null;
  UOMCateg?: any;
  
  // === IDs ===
  UOMId?: number;
  UOMPOId?: number;
  CategId?: number;
  POSCategId?: number | null;
  CompanyId?: number | null;
  Product_UOMId?: number | null;
  CreatedById?: number | null;
  
  // === VARIANTS & ATTRIBUTES ===
  ProductVariants: TPOSProductVariantDetail[];
  AttributeLines?: Array<{
    Attribute: {
      Id: number;
    };
    Values: Array<{
      Id: number;
      Name: string;
      Code: string | null;
      Sequence: number | null;
      AttributeId: number;
      AttributeName: string;
      PriceExtra: number | null;
      NameGet: string;
      DateCreated: string | null;
    }>;
    AttributeId: number;
  }>;
  
  // === POLICIES ===
  Tracking?: string | null;
  InvoicePolicy?: string | null;
  PurchaseMethod?: string | null;
  CostMethod?: string | null;
  PropertyCostMethod?: string | null;
  PropertyValuation?: string | null;
  Valuation?: string | null;
  
  // === OTHER ===
  Weight?: number;
  Volume?: number | null;
  SaleDelay?: number;
  Version?: number;
  Description?: string | null;
  LastUpdated?: string | null;
  DateCreated?: string | null;
  
  // === TAXES & TEAMS ===
  Taxes?: any[];
  SupplierTaxes?: any[];
  TaxesIds?: any[];
  Product_Teams?: any[];
  
  // === RELATED ENTITIES ===
  Images?: any[];
  UOMView?: any;
  Distributor?: any;
  Importer?: any;
  Producer?: any;
  OriginCountry?: any;
  UOMLines?: any[];
  ComboProducts?: any[];
  ProductSupplierInfos?: any[];
  Items?: any[];
  
  // === STATISTICS ===
  StockValue?: number | null;
  SaleValue?: number | null;
  PosSalesCount?: number | null;
  AmountTotal?: number | null;
  TaxAmount?: number | null;
  Factor?: number | null;
  
  // === MISC ===
  Tags?: any[] | null;
  OrderTag?: any | null;
  StringExtraProperties?: any | null;
  NameCombos?: any[];
  RewardName?: string | null;
  Error?: any | null;
  DisplayAttributeValues?: any | null;
  NameTemplateNoSign?: string | null;
  ProductTmplEnableAll?: boolean;
}

/**
 * Product variant details
 */
export interface TPOSProductVariantDetail {
  Id: number;
  ProductIdBienThe: number;
  Name: string;
  NameGet?: string; // ‚úÖ T√™n bi·∫øn th·ªÉ hi·ªÉn th·ªã (c√≥ th·ªÉ kh√°c v·ªõi Name)
  DefaultCode: string;
  Barcode: string | null;
  QtyAvailable: number;
  VirtualAvailable?: number; // ‚úÖ Th√™m field n√†y theo file m·∫´u
  QtyForecast: number;
  ListPrice: number;
  PurchasePrice: number;
  StandardPrice: number;
  Active: boolean;
  AttributeValues: TPOSAttributeValueDetail[];
}

/**
 * Attribute value details
 */
export interface TPOSAttributeValueDetail {
  Id: number;
  Name: string;
  AttributeId: number;
  AttributeName: string;
  PriceExtra: number;
}

// =====================================================
// STOCK CHANGE INTERFACES
// =====================================================

/**
 * Item trong response t·ª´ /api/stock-change-get-template
 * Response structure: { value: [StockChangeItem, ...] }
 */
export interface StockChangeItem {
  Product: {
    Id: number;              // Variant ID
    Name: string;
    DefaultCode: string;
    Barcode: string | null;
  };
  LocationId: number;         // Kho (c·ªë ƒë·ªãnh = 12)
  NewQuantity: number;        // S·ªë l∆∞·ª£ng m·ªõi (s·∫Ω update)
  TheoreticalQuantity: number;// S·ªë l∆∞·ª£ng hi·ªán t·∫°i
}

/**
 * Response t·ª´ GET template
 */
export interface StockChangeTemplateResponse {
  value: StockChangeItem[];
}

/**
 * Payload ƒë·ªÉ POST quantity changes
 */
export interface StockChangePostPayload {
  model: StockChangeItem[];  // Array of modified items
}

/**
 * Payload ƒë·ªÉ execute stock change
 */
export interface StockChangeExecutePayload {
  ids: number[];  // Array of ProductTmplId
}

/**
 * Update product payload - MUST send back entire product object
 * Only override the fields that were edited
 */
export type TPOSUpdateProductPayload = any; // Accept full product structure from API
export interface TPOSProductItem {
  id: string;
  product_code: string | null;
  base_product_code: string | null;
  product_name: string;
  variant: string | null;
  quantity: number;
  unit_price: number;
  selling_price: number;
  product_images: string[] | null;
  price_images: string[] | null;
  purchase_order_id: string;
  supplier_name: string;
  tpos_product_id?: number | null;
}

// =====================================================
// TPOS API CALLS
// =====================================================

/**
 * Create product directly using InsertV2 API
 */
export async function createProductDirectly(
  item: TPOSProductItem,
  imageBase64: string | null,
  attributeLines: any[]
): Promise<any> {
  const token = await getActiveTPOSToken();
  if (!token) throw new Error("TPOS Bearer Token not found");
  
  const payload = {
    Id: 0,
    Name: item.product_name,
    Type: "product",
    ListPrice: item.selling_price || 0,
    PurchasePrice: item.unit_price || 0,
    DefaultCode: item.base_product_code || item.product_code,
    Image: imageBase64 ? cleanBase64(imageBase64) : null,
    ImageUrl: null,
    Thumbnails: [],
    AttributeLines: attributeLines,
    Active: true,
    SaleOK: true,
    PurchaseOK: true,
    UOMId: 1,
    UOMPOId: 1,
    CategId: 2,
    CompanyId: 1,
    Tracking: "none",
    InvoicePolicy: "order",
    PurchaseMethod: "receive",
    AvailableInPOS: true,
    DiscountSale: 0,
    DiscountPurchase: 0,
    StandardPrice: 0,
    Weight: 0,
    SaleDelay: 0,
    UOM: {
      Id: 1, Name: "C√°i", Rounding: 0.001, Active: true,
      Factor: 1, FactorInv: 1, UOMType: "reference",
      CategoryId: 1, CategoryName: "ƒê∆°n v·ªã"
    },
    UOMPO: {
      Id: 1, Name: "C√°i", Rounding: 0.001, Active: true,
      Factor: 1, FactorInv: 1, UOMType: "reference",
      CategoryId: 1, CategoryName: "ƒê∆°n v·ªã"
    },
    Categ: {
      Id: 2, Name: "C√≥ th·ªÉ b√°n", CompleteName: "C√≥ th·ªÉ b√°n",
      Type: "normal", PropertyCostMethod: "average",
      NameNoSign: "Co the ban", IsPos: true
    },
    Items: [],
    UOMLines: [],
    ComboProducts: [],
    ProductSupplierInfos: []
  };
  
  const response = await fetch(
    `${TPOS_CONFIG.API_BASE}/ODataService.InsertV2?$expand=ProductVariants,UOM,UOMPO`,
    {
      method: 'POST',
      headers: await getTPOSHeaders(token),
      body: JSON.stringify(payload)
    }
  );
  
  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`Failed to create product: ${errorText}`);
  }
  
  return response.json();
}

// DEPRECATED: Excel upload method - keeping for reference
// export async function uploadExcelToTPOS(excelBlob: Blob): Promise<TPOSUploadResponse> { ... }

// DEPRECATED: No longer needed with InsertV2 direct method
// export async function getLatestProducts(count: number): Promise<any[]> { ... }

export async function getProductDetail(productId: number): Promise<any> {
  const token = await getActiveTPOSToken();
  if (!token) {
    throw new Error("TPOS Bearer Token not found");
  }
  
  console.log(`üîé [TPOS] Fetching product detail for ID: ${productId}`);
  
  await randomDelay(200, 600);

  // GetViewV2 doesn't support complex expand - fetch without expand or with basic ones
  const url = `${TPOS_CONFIG.API_BASE}/ODataService.GetViewV2?$filter=Id eq ${productId}`;
  
  console.log(`üì° [TPOS] Calling: ${url}`);

  const response = await fetch(url, {
    method: "GET",
    headers: await getTPOSHeaders(token),
  });

  if (!response.ok) {
    const errorText = await response.text();
    console.error(`‚ùå [TPOS] Failed to fetch product ${productId}:`, errorText);
    throw new Error(`Failed to fetch product detail: ${response.status} - ${errorText}`);
  }

  const data = await response.json();
  const products = data.value || data;
  
  if (!products || products.length === 0) {
    throw new Error(`Product with ID ${productId} not found in TPOS`);
  }

  console.log(`‚úÖ [TPOS] Successfully fetched product ${productId}:`, products[0].Name || products[0].Code);
  
  return products[0];
}


// =====================================================
// ATTRIBUTES MANAGEMENT
// =====================================================

export interface TPOSAttribute {
  Id: number;
  Name: string;
  Code?: string;
}


// =====================================================
// FETCH & EDIT TPOS PRODUCT FUNCTIONS
// =====================================================

/**
 * T√¨m s·∫£n ph·∫©m TPOS theo DefaultCode
 * Endpoint: GET /ProductTemplate/OdataService.GetViewV2
 */
export async function searchTPOSProductByCode(
  productCode: string
): Promise<TPOSProductSearchResult | null> {
  const { queryWithAutoRefresh } = await import('./query-with-auto-refresh');
  
  return queryWithAutoRefresh(async () => {
    const token = await getActiveTPOSToken();
    if (!token) {
      throw new Error("TPOS Bearer Token not found. Please configure in Settings.");
    }
    
    await randomDelay(200, 600);
    
    const url = `https://tomato.tpos.vn/odata/ProductTemplate/OdataService.GetViewV2?Active=true&DefaultCode=${encodeURIComponent(productCode)}&$top=50&$orderby=DateCreated desc&$filter=Active+eq+true&$count=true`;
    
    console.log(`üîç [Fetch & Edit] Searching product: ${productCode}`);
    
    const response = await fetch(url, {
      method: 'GET',
      headers: await getTPOSHeaders(token),
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error(`‚ùå [Fetch & Edit] Search failed: ${errorText}`);
      throw new Error(`TPOS API error: ${response.status}`);
    }
    
    const data = await response.json();
    
    if (data.value && data.value.length > 0) {
      const product = data.value.find((p: any) => p.DefaultCode === productCode);
      if (product) {
        console.log(`‚úÖ [Fetch & Edit] Found product:`, product.Name);
        return product as TPOSProductSearchResult;
      }
    }
    
    console.log(`‚ùå [Fetch & Edit] Product not found: ${productCode}`);
    return null;
  }, 'tpos');
}

/**
 * L·∫•y chi ti·∫øt ƒë·∫ßy ƒë·ªß s·∫£n ph·∫©m t·ª´ TPOS (bao g·ªìm variants v√† attributes)
 * Endpoint: GET /ProductTemplate({Id})?$expand=...
 */
export async function getTPOSProductFullDetails(
  productId: number
): Promise<TPOSProductFullDetails> {
  const { queryWithAutoRefresh } = await import('./query-with-auto-refresh');
  
  return queryWithAutoRefresh(async () => {
    const token = await getActiveTPOSToken();
    if (!token) {
      throw new Error("TPOS Bearer Token not found");
    }
    
    await randomDelay(200, 600);
    
    const url = `https://tomato.tpos.vn/odata/ProductTemplate(${productId})?$expand=UOM,UOMCateg,Categ,UOMPO,POSCateg,Taxes,SupplierTaxes,Product_Teams,Images,UOMView,Distributor,Importer,Producer,OriginCountry,AttributeLines($expand=Attribute,Values),ProductVariants($expand=UOM,Categ,UOMPO,POSCateg,AttributeValues)`;
    
    console.log(`üì¶ [Fetch & Edit] Fetching full details for product ID: ${productId}`);
    
    const response = await fetch(url, {
      method: 'GET',
      headers: await getTPOSHeaders(token),
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error(`‚ùå [Fetch & Edit] Failed to fetch details: ${errorText}`);
      throw new Error(`Failed to fetch product details: ${response.status}`);
    }
    
    const data = await response.json();
    console.log(`‚úÖ [Fetch & Edit] Successfully fetched details:`, data.Name);
    
    return data as TPOSProductFullDetails;
  }, 'tpos');
}

/**
 * C·∫≠p nh·∫≠t th√¥ng tin s·∫£n ph·∫©m l√™n TPOS
 * Endpoint: POST /ProductTemplate/ODataService.UpdateV2
 */
export async function updateTPOSProductDetails(
  payload: any
): Promise<any> {
  const { queryWithAutoRefresh } = await import('./query-with-auto-refresh');
  
  return queryWithAutoRefresh(async () => {
    const token = await getActiveTPOSToken();
    if (!token) {
      throw new Error("TPOS Bearer Token not found");
    }
    
    await randomDelay(200, 600);
    
    const url = 'https://tomato.tpos.vn/odata/ProductTemplate/ODataService.UpdateV2';
    
    console.log(`üì§ [Fetch & Edit] Updating product ID: ${payload.Id}`);
    console.log(`üìã [Fetch & Edit] Full payload (with all fields):`, payload);
    
    // Only clean Base64 if Image field exists
    const cleanedPayload = { ...payload };
    if (cleanedPayload.Image && typeof cleanedPayload.Image === 'string') {
      cleanedPayload.Image = cleanBase64(cleanedPayload.Image);
    }
    
    console.log(`üì§ [Fetch & Edit] Sending cleaned payload to TPOS`);
    
    const response = await fetch(url, {
      method: 'POST',
      headers: await getTPOSHeaders(token),
      body: JSON.stringify(cleanedPayload)
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error(`‚ùå [Fetch & Edit] Update failed: ${errorText}`);
      console.error(`‚ùå [Fetch & Edit] Status: ${response.status}`);
      console.error(`‚ùå [Fetch & Edit] Payload sent:`, JSON.stringify(cleanedPayload, null, 2));
      
      // Parse error message n·∫øu c√≥
      let errorMessage = errorText;
      try {
        const errorJson = JSON.parse(errorText);
        errorMessage = errorJson.error?.message || errorJson.message || errorText;
      } catch {}
      
      throw new Error(`Failed to update product: ${errorMessage}`);
    }
    
    const data = await response.json();
    console.log(`‚úÖ [Fetch & Edit] Product updated successfully:`, data);
    
    return data;
  }, 'tpos');
}

// =====================================================
// STOCK CHANGE FUNCTIONS - OData Direct Update
// =====================================================

/**
 * L·∫•y chi ti·∫øt m·ªôt variant t·ª´ TPOS
 * Endpoint: GET /odata/Product({Id})?$expand=...
 * 
 * @param variantId - ID c·ªßa variant (Product ID, kh√¥ng ph·∫£i ProductTemplate ID)
 * @returns Chi ti·∫øt ƒë·∫ßy ƒë·ªß c·ªßa variant
 */
export async function getVariantDetails(variantId: number): Promise<any> {
  const { queryWithAutoRefresh } = await import('./query-with-auto-refresh');
  
  return queryWithAutoRefresh(async () => {
    const token = await getActiveTPOSToken();
    if (!token) {
      throw new Error("TPOS Bearer Token not found");
    }
    
    await randomDelay(200, 600);
    
    const url = `https://tomato.tpos.vn/odata/Product(${variantId})?$expand=UOM,Categ,UOMPO,POSCateg,AttributeValues`;
    
    console.log(`üì¶ [Change Size] Fetching variant details: ${variantId}`);
    
    const response = await fetch(url, {
      method: 'GET',
      headers: await getTPOSHeaders(token),
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error(`‚ùå Failed to fetch variant ${variantId}:`, errorText);
      throw new Error(`Failed to fetch variant: ${response.status}`);
    }
    
    const data = await response.json();
    console.log(`‚úÖ Fetched variant ${variantId}:`, data.DefaultCode, `Qty: ${data.QtyAvailable}`);
    
    return data;
  }, 'tpos');
}

/**
 * C·∫≠p nh·∫≠t stock c·ªßa m·ªôt variant
 * Endpoint: POST /odata/Product/ODataService.UpdateV2
 * 
 * ‚ö†Ô∏è QUAN TR·ªåNG: Ph·∫£i truy·ªÅn FULL variant data, ch·ªâ thay ƒë·ªïi QtyAvailable
 * 
 * @param variantId - ID c·ªßa variant
 * @param newQty - S·ªë l∆∞·ª£ng m·ªõi
 * @param fullVariantData - D·ªØ li·ªáu ƒë·∫ßy ƒë·ªß c·ªßa variant (t·ª´ getVariantDetails)
 * @returns Response t·ª´ TPOS
 */
export async function updateVariantStock(
  variantId: number, 
  newQty: number,
  fullVariantData: any
): Promise<any> {
  const { queryWithAutoRefresh } = await import('./query-with-auto-refresh');
  
  return queryWithAutoRefresh(async () => {
    const token = await getActiveTPOSToken();
    if (!token) {
      throw new Error("TPOS Bearer Token not found");
    }
    
    await randomDelay(200, 600);
    
    const url = 'https://tomato.tpos.vn/odata/Product/ODataService.UpdateV2';
    
    // ‚úÖ Clone full data v√† ch·ªâ update QtyAvailable
    const payload = {
      ...fullVariantData,
      QtyAvailable: newQty,
      VirtualAvailable: newQty  // ƒê·ªìng b·ªô c·∫£ VirtualAvailable
    };
    
    // Remove expanded fields (TPOS kh√¥ng cho ph√©p g·ª≠i l·∫°i)
    delete payload.UOM;
    delete payload.Categ;
    delete payload.UOMPO;
    delete payload.POSCateg;
    delete payload.AttributeValues;
    
    console.log(`üì§ [Change Size] Updating variant ${variantId}: ${fullVariantData.DefaultCode}`);
    console.log(`   Old Qty: ${fullVariantData.QtyAvailable} ‚Üí New Qty: ${newQty}`);
    
    const response = await fetch(url, {
      method: 'POST',
      headers: await getTPOSHeaders(token),
      body: JSON.stringify(payload)
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error(`‚ùå Failed to update variant ${variantId}:`, errorText);
      throw new Error(`Failed to update stock: ${response.status} - ${errorText}`);
    }
    
    const data = await response.json();
    console.log(`‚úÖ Successfully updated variant ${variantId} stock to ${newQty}`);
    
    return data;
  }, 'tpos');
}

// =====================================================
// DEPRECATED STOCK CHANGE FUNCTIONS (using /api/stock-change-*)
// These functions are kept for reference but should not be used
// =====================================================

/**
 * @deprecated Use getVariantDetails + updateVariantStock instead
 * Step 1: L·∫•y template ƒë·ªÉ thay ƒë·ªïi s·ªë l∆∞·ª£ng t·ªìn kho
 * POST https://tomato.tpos.vn/api/stock-change-get-template
 * 
 * @param productTmplId - ID c·ªßa product template (s·∫£n ph·∫©m cha)
 * @returns Array of stock change items cho t·ª´ng variant v√† location
 */
export async function getStockChangeTemplate(
  productTmplId: number
): Promise<StockChangeItem[]> {
  const { queryWithAutoRefresh } = await import('./query-with-auto-refresh');
  
  return queryWithAutoRefresh(async () => {
    const token = await getActiveTPOSToken();
    if (!token) {
      throw new Error("TPOS Bearer Token not found");
    }
    
    await randomDelay(200, 600);
    
    const url = 'https://tomato.tpos.vn/api/stock-change-get-template';
    
    console.log(`üìã [Stock Change] Step 1: Getting template for ProductTmplId: ${productTmplId}`);
    
    const response = await fetch(url, {
      method: 'POST',
      headers: await getTPOSHeaders(token),
      body: JSON.stringify({
        model: {
          ProductTmplId: productTmplId
        }
      })
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error(`‚ùå [Stock Change] Get template failed:`, errorText);
      throw new Error(`Failed to get stock change template: ${response.status}`);
    }
    
    const data: StockChangeTemplateResponse = await response.json();
    
    // Response c√≥ d·∫°ng { value: [...] }
    if (!data.value || !Array.isArray(data.value)) {
      throw new Error("Invalid response format from TPOS");
    }
    
    console.log(`‚úÖ [Stock Change] Template received:`, {
      totalItems: data.value.length,
      items: data.value.map(item => ({
        variantId: item.Product.Id,
        code: item.Product.DefaultCode,
        locationId: item.LocationId,
        currentQty: item.TheoreticalQuantity
      }))
    });
    
    return data.value;
  }, 'tpos');
}

/**
 * @deprecated Use getVariantDetails + updateVariantStock instead
 * Step 2: G·ª≠i s·ªë l∆∞·ª£ng ƒë√£ thay ƒë·ªïi l√™n TPOS
 * POST https://tomato.tpos.vn/api/stock-change-post-qty
 * 
 * @param items - Array of modified stock change items
 */
export async function postStockChangeQuantity(
  items: StockChangeItem[]
): Promise<any> {
  const { queryWithAutoRefresh } = await import('./query-with-auto-refresh');
  
  return queryWithAutoRefresh(async () => {
    const token = await getActiveTPOSToken();
    if (!token) {
      throw new Error("TPOS Bearer Token not found");
    }
    
    await randomDelay(200, 600);
    
    const url = 'https://tomato.tpos.vn/api/stock-change-post-qty';
    
    console.log(`üì§ [Stock Change] Step 2: Posting quantity changes...`);
    console.log(`üìã [Stock Change] Modified items:`, items.map(item => ({
      variantId: item.Product.Id,
      code: item.Product.DefaultCode,
      locationId: item.LocationId,
      oldQty: item.TheoreticalQuantity,
      newQty: item.NewQuantity,
      diff: item.NewQuantity - item.TheoreticalQuantity
    })));
    
    const payload: StockChangePostPayload = {
      model: items
    };
    
    const response = await fetch(url, {
      method: 'POST',
      headers: await getTPOSHeaders(token),
      body: JSON.stringify(payload)
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error(`‚ùå [Stock Change] Post quantity failed:`, errorText);
      throw new Error(`Failed to post stock changes: ${response.status}`);
    }
    
    const data = await response.json();
    console.log(`‚úÖ [Stock Change] Quantities posted successfully, response:`, data);
    
    return data;
  }, 'tpos');
}

/**
 * @deprecated Use getVariantDetails + updateVariantStock instead
 * Step 3: Th·ª±c thi vi·ªác thay ƒë·ªïi s·ªë l∆∞·ª£ng
 * POST https://tomato.tpos.vn/api/stock-change-execute
 * 
 * @param productTmplId - ID c·ªßa product template
 */
export async function executeStockChange(
  postQtyResponse: any
): Promise<void> {
  const { queryWithAutoRefresh } = await import('./query-with-auto-refresh');
  
  return queryWithAutoRefresh(async () => {
    const token = await getActiveTPOSToken();
    if (!token) {
      throw new Error("TPOS Bearer Token not found");
    }
    
    await randomDelay(200, 600);
    
    const url = 'https://tomato.tpos.vn/api/stock-change-execute';
    
    // Extract IDs from Step 2 response
    if (!postQtyResponse || !Array.isArray(postQtyResponse.value) || postQtyResponse.value.length === 0) {
      throw new Error("Kh√¥ng th·ªÉ l·∫•y IDs t·ª´ response c·ªßa b∆∞·ªõc ƒëƒÉng t·∫£i s·ªë l∆∞·ª£ng.");
    }
    
    const idsToExecute = postQtyResponse.value.map((item: any) => item.Id);
    
    console.log(`‚úÖ [Stock Change] Step 3: Executing stock change for IDs:`, idsToExecute);
    
    const payload: StockChangeExecutePayload = {
      ids: idsToExecute
    };
    
    const response = await fetch(url, {
      method: 'POST',
      headers: await getTPOSHeaders(token),
      body: JSON.stringify(payload)
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error(`‚ùå [Stock Change] Execute failed:`, errorText);
      throw new Error(`Failed to execute stock change: ${response.status}`);
    }
    
    console.log(`‚úÖ [Stock Change] Stock change executed successfully`);
  }, 'tpos');
}

// =====================================================
// DEPRECATED FUNCTIONALITY
// =====================================================
// All variant generation, product sync, and TPOS upload functions have been removed.
// Only search and direct API calls (searchTPOSProduct, createProductDirectly, getProductDetail) remain.

